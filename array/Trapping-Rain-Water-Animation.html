<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trapping Rain Water Animation</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-SgOJa3DmI69IUzQ2PVdRZhwQ+dy64/BUtbMJw1MZ8t5HZApcHrRKUc4W0kG879m7" crossorigin="anonymous">
  <style>
    .bar {
      background-color: black;
      width: 2.5rem;
      border: 1px solid white;
      text-align: center;
    }

    pre {
      color: tomato;
    }
  </style>
</head>

<body>
  <div class="container">

    <h1>Trapping Rain Water Animation</h1>
    <pre id="overview"></pre>

    <div class="row mt-4 gap-5">
      <div class="col">
        <h2>Array Visualization</h2>
        <div id="arrayVisualization" class="d-flex justify-content-center align-items-end">
          <!-- Bars will be generated here -->
        </div>
      </div>
      <div class="col">
        <h2>Water Trapped Visualization <b class="fs-6">(Two Pointer Approach)</b></h2>
        <div id="waterTrappedVisualization" class="d-flex justify-content-center align-items-end">
          <!-- Water trapped will be visualized here -->
        </div>
        <pre class="mt-3">
          Water Trapped = <b id="waterTrapped2"></b>
          Left = <b id="leftElement"></b>
          Right = <b id="rightElement"></b>
          Left Max = <b id="leftMaxElement"></b>
          Right Max = <b id="rightMaxElement"></b>
        </pre>
        <div class="d-flex gap-3">
          <button class="btn btn-outline-primary" type="button" id="btnAnimate">Animate</button>
          <button class="btn btn-outline-danger" type="button" id="btnStop">Stop</button>
          <button class="btn btn-outline-danger" type="button" id="btnReset">Reset</button>
          <button class="btn btn-outline-info" type="button" id="btnPrevious">Previous</button>
          <button class="btn btn-outline-success" type="button" id="btnNext">Next</button>
        </div>
      </div>

      <div class="my-5"></div>

    </div>


    <script>
      let isAnimating = false;
      let timeoutId = null;
      let currentIndex = 0;
      const STACK = [];
      const A = [2, 1, 3, 2, 1, 2, 4, 3, 2, 1, 3, 1];
      overview.innerText = `A = [${A.join(', ')}]\n`
        + `N = ${A.length}\n`
        + `Water Trapped = ${TrappingRainWater(A)}`;

      generateBars(A);

      setTimeout(() => {
        TrappingRainWaterAnimator(A);
      }, timeout = 1000);

      function generateBars(A) {
        arrayVisualization.innerHTML = '';
        waterTrappedVisualization.innerHTML = '';

        A.forEach((height, index) => {
          const bar = document.createElement('div');
          bar.innerText = height;
          bar.className = 'bar';
          bar.style.height = `${height * 48}px`;
          arrayVisualization.appendChild(bar);
          // copy above bar
          const waterBar = bar.cloneNode(true);
          waterTrappedVisualization.appendChild(waterBar);
        });
      }

      // Buttons
      btnAnimate.addEventListener('click', () => {
        // Reset the animation
        stopAnimation();
        const bars = waterTrappedVisualization.childNodes;
        for (let i = 0; i < bars.length; i++) {
          waterTrappedVisualization.childNodes[i].innerHTML = bars[i].innerHTML;
        }
        TrappingRainWaterAnimator(A);
      });
      btnStop.addEventListener('click', () => {
        pauseAnimation();
      });
      btnReset.addEventListener('click', () => {
        stopAnimation();
        currentIndex = 0;
        const bars = arrayVisualization.childNodes;
        for (let i = 0; i < bars.length; i++) {
          waterTrappedVisualization.childNodes[i].innerText = bars[i].innerText;
        }
      });
      btnPrevious.addEventListener('click', () => {
        const bars = arrayVisualization.childNodes;
        for (let i = 0; i < bars.length; i++) {
          waterTrappedVisualization.childNodes[i].innerText = bars[i].innerText;
        }
        currentIndex--;
        TrappingRainWaterAnimator(A, currentIndex);
      });
      btnNext.addEventListener('click', () => {
        const bars = arrayVisualization.childNodes;
        for (let i = 0; i < bars.length; i++) {
          waterTrappedVisualization.childNodes[i].innerText = bars[i].innerText;
        }
        currentIndex++;
        TrappingRainWaterAnimator(A, currentIndex);
      });

      function stopAnimation() {
        clearTimeout(timeoutId);
        isAnimating = false;
        waterTrapped2.innerText = 0;
        leftElement.innerText = 0;
        rightElement.innerText = 0;
        leftMaxElement.innerText = 0;
        rightMaxElement.innerText = 0;
      }
      function pauseAnimation() {
        clearTimeout(timeoutId);
        isAnimating = false;
      }
      async function TrappingRainWaterAnimator(A, breakpoint = null) {
        for (let index = 0; index < STACK.length; index++) {
          currentIndex = index;

          if (breakpoint !== null && index === breakpoint) {
            // stop the animation
            isAnimating = false;
            return;
          }
          const { left, right, leftMax, rightMax, water } = STACK[index];

          waterTrappedVisualization.childNodes[left].innerHTML = `<pre>${A[left]}\nL</pre>`;
          waterTrappedVisualization.childNodes[right].innerHTML = `<pre>${A[right]}\nR</pre>`;
          waterTrapped2.innerText = water;
          leftElement.innerText = left;
          rightElement.innerText = right;
          leftMaxElement.innerText = leftMax;
          rightMaxElement.innerText = rightMax;

          if (breakpoint == null) {
            // wait for 1 second
            await new Promise(resolve => {
              timeoutId = setTimeout(resolve, 1000);
            });
          }

        }
      }

      function TrappingRainWater(A) {
        STACK.length = 0;
        let water = 0;
        let left = 0;
        let right = A.length - 1;
        let leftMax = 0;
        let rightMax = 0;
        while (left < right) {
          STACK.push({ left, right, leftMax, rightMax, water });
          leftMax = Math.max(leftMax, A[left]);
          rightMax = Math.max(rightMax, A[right]);
          if (leftMax < rightMax) {
            water += leftMax - A[left];
            left++;
          } else {
            water += rightMax - A[right];
            right--;
          }
        }
        return water;
      }
    </script>

</body>

</html>